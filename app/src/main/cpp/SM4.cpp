
//SMS4 分组长度128比特，密钥长度128/192/256比特（本程序实现128）


#include <string.h>
#include <stdio.h>
#include "SM4.h"



#define	SMS4_SUCCEED		0	//成功
#define	mlen_err	1	
#define	keylen_err	2
#define	clen_err	3

U8 s[256]={
0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
};
U32 FK[4] = {0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc};
U32 CK[32] =
{
0x00070e15,0x1c232a31,0x383f464d,0x545b6269,
0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,
0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,
0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,
0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,
0x30373e45,0x4c535a61,0x686f767d,0x848b9299,
0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,
0x10171e25,0x2c333a41,0x484f565d,0x646b7279
};

U32 T(U32 a)
{
	U8 t[4];
	U32 b;
	t[0]=s[(U8)(a>>24)];
	t[1]=s[(U8)(a>>16)];
	t[2]=s[(U8)(a>>8)];
	t[3]=s[(U8)a];

	b = (U32)t[0];
	b = (b<<8)|(U32)t[1];
	b = (b<<8)|(U32)t[2];
	b = (b<<8)|(U32)t[3];

	b = b^ROL(b,2)^ROL(b,10)^ROL(b,18)^ROL(b,24);

	return b;
	
}

U32 T1(U32 a)
{
	U8 t[4];
	U32 b;
	t[0]=s[(U8)(a>>24)];
	t[1]=s[(U8)(a>>16)];
	t[2]=s[(U8)(a>>8)];
	t[3]=s[(U8)a];

	b = (U32)t[0];
	b = (b<<8)|(U32)t[1];
	b = (b<<8)|(U32)t[2];
	b = (b<<8)|(U32)t[3];

	b = b^ROL(b,13)^ROL(b,23);

	return b;
	
}

/**********************************************
void SMS4_Encrypt(U32 *p, U32 *c, U32 *EK)
功能：SMS4单分组加密
输入：p 明文(16字节)
	  EK 扩展密钥（32个字）
输出：c 密文（16字节） 
**************************************************/
void SMS4_Encrypt(U32 *p, U32 *c, U32 *EK)
{
	U32 X[4],a,b;
	int i;

	X[0] = p[0];
	X[1] = p[1];
	X[2] = p[2];
	X[3] = p[3];

	for(i=0; i<31; i++)
	{
		a = X[1]^X[2]^X[3]^EK[i];
		b = X[0]^T(a);

		X[0] = X[1];
		X[1] = X[2];
		X[2] = X[3];
		X[3] = b;
		
	}

	a = X[1]^X[2]^X[3]^EK[31];
	X[0] = X[0]^T(a);

	b = X[1];
	X[1] = X[3];
	X[3] = b;

	c[0] = X[0];
	c[1] = X[1];
	c[2] = X[2];
	c[3] = X[3];

	
}

/**********************************************
void SMS4_Decrypt(U32 *c, U32 *p, U32 *EK)
功能：SMS4单分组解密
输入：c 密文(16字节)
	  EK 扩展密钥（32个字）
输出：p 明文（16字节） 
**************************************************/
void SMS4_Decrypt(U32 *c, U32 *p, U32 *EK)
{
	U32 X[4],a,b;
	int i;

	X[0] = c[0];
	X[1] = c[1];
	X[2] = c[2];
	X[3] = c[3];

	for(i=31; i>0; i--)
	{
		a = X[1]^X[2]^X[3]^EK[i];
		b = X[0]^T(a);

		X[0] = X[1];
		X[1] = X[2];
		X[2] = X[3];
		X[3] = b;
		
	}

	a = X[1]^X[2]^X[3]^EK[0];
	X[0] = X[0]^T(a);

	b = X[1];
	X[1] = X[3];
	X[3] = b;

	p[0] = X[0];
	p[1] = X[1];
	p[2] = X[2];
	p[3] = X[3];

}

/**********************************************
void SMS4_keygen(U8 *key, int key_len, U32 *EK)
功能：SMS4密钥扩展
输入：key 密钥(16字节)
	  key_len密钥长度（以字节计）
输出：EK 扩展密钥（32个字）
**************************************************/

void SMS4_keygen(U8 *key, int key_len, U32 *EK)
{
	U32 t,K[4];
	int i;

	U8ToU32(key,K,4);

	for(i=0; i<4; i++)
	{
		K[i]^=FK[i];
	}

	for(i=0; i<32; i++)
	{
		t = K[(i+1)%4]^K[(i+2)%4]^K[(i+3)%4]^CK[i];
		K[i%4]^= T1(t);
		EK[i] = K[i%4];
	}
}

/***********************************************************************
int SMS4_CBC_Encrypt(unsigned char *IV, unsigned char *p,int p_len, unsigned char *key, int key_len, unsigned char *c, int *c_len)
功能：SM4加密CBC模式
输入：IV 初始值（16字节）
	  p  明文（16字节的倍数）
	  p_len 明文长度（以字节计）
	  key 密钥（16字节）
	  key_len 密钥长度（以字节计）

输出：IV 初始值（16字节，更新后）
	  c 密文（16字节的倍数）
	  c_len 密文长度（以字节计）
返回值：0成功
		1明文长度错误
		2密钥长度错误

*************************************************************************/
int SMS4_CBC_Encrypt(unsigned char *IV, unsigned char *p,int p_len, unsigned char *key, int key_len, unsigned char *c, int *c_len)
{
	int i,m;
	U32 in[4],out[4];
	U32 Expand_key[32];
	
	if((p_len%16)!=0) 
	{
		return mlen_err;
	}

	if(key_len!=16)
	{
		return keylen_err;
	}
	 m = p_len/16;

	 SMS4_keygen(key, key_len, Expand_key);

	 
	 U8ToU32(IV, out, 4);

     for(i = 0;i < m;i++ )
	 {
		 U8ToU32(p+16*i, in , 4);
		 
		 in[0]^= out[0];
		 in[1]^= out[1];
		 in[2]^= out[2];
		 in[3]^= out[3];

		 SMS4_Encrypt(in, out, Expand_key);
		 U32ToU8(out, c+16*i, 4);

	 }
	 c_len[0]=p_len;
	 for(i=0; i<16; i++)
	 {
		 IV[i]=c[16*(m-1)+i];
	 }

	 return SMS4_SUCCEED;


}

/***********************************************************************
int SMS4_CBC_Decrypt(unsigned char *IV, unsigned char *c,int c_len, unsigned char *key, int key_len, unsigned char *p, int *p_len)
功能：SM4解密CBC模式
输入：IV 初始值（16字节）
	  c  密文（16字节的倍数）
	  c_len 密文长度（以字节计）
	  key 密钥（16字节）
	  key_len 密钥长度（以字节计）

输出：IV 初始值（16字节，更新后）
	  p 明文（16字节的倍数）
	  p_len 明文长度（以字节计）
返回值：0成功
		2密钥长度错误
		3密文长度错误

*************************************************************************/
int SMS4_CBC_Decrypt(unsigned char *IV, unsigned char *c,int c_len, unsigned char *key, int key_len, unsigned char *p, int *p_len)
{
	int m,i;
	U32	in[4],out[4],t[4];
	U32 Expand_key[32];
	
	if((c_len%16)!=0) 
	{
		return clen_err;
	}

	if(key_len!=16)
	{
		return keylen_err;
	}
	 m = c_len/16;

	 SMS4_keygen(key, key_len, Expand_key);

	 
	 U8ToU32(IV, t, 4);

     for(i = 0;i < m;i++ )
	 {
		 U8ToU32(c+16*i, in , 4);

		 SMS4_Decrypt(in, out, Expand_key);

         out[0]^= t[0];
		 out[1]^= t[1];
		 out[2]^= t[2];
		 out[3]^= t[3];

		 U32ToU8(out, p+16*i, 4);

		 t[0] = in[0];
		 t[1] = in[1];
		 t[2] = in[2];
		 t[3] = in[3];
		
	 }
	 p_len[0]=c_len;

	 U32ToU8(in, IV, 4);

	 return SMS4_SUCCEED;	

}

int test_SMS4()
{
	U8 key1[16]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
	U8 p1[16]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
	U8 c1[16]={0x68,0x1e,0xdf,0x34,0xd2,0x06,0x96,0x5e,0x86,0xb3,0xe9,0x4f,0x53,0x6e,0x42,0x46};
	U8 c2[16]={0x59,0x52,0x98,0xc7,0xc6,0xfd,0x27,0x1f,0x04,0x02,0xf8,0x04,0xc3,0x3d,0x3f,0x66};
	U8 p2[64]={0xe3,0xb0,0xc4,0x42,0x98,0xfc,0x1c,0x14,0x9a,0xfb,0xf4,0xc8,0x99,0x6f,0xb9,0x24,0x27,0xae,0x41,0xe4,0x64,0x9b,0x93,0x4c,0xa4,0x95,0x99,0x1b,0x78,0x52,0xb8,0x55,
				0xd2,0x9d,0x57,0x6f,0xce,0xa3,0xa3,0xa7,0xed,0x90,0x99,0xf2,0x92,0x73,0xd7,0x8e,0xd8,0x25,0x24,0x81,0xdf,0xe4,0x56,0x55,0x41,0xe4,0x64,0x9b,0x93,0x4c,0xa4,0x95};
	U8 key2[16]={0x27,0xae,0x41,0xe4,0x64,0x9b,0x93,0x4c,0xa4,0x95,0x99,0x1b,0x78,0x52,0xb8,0x55};
	U8 IV1[16]={0x16,0x31,0x89,0x5c,0xb6,0xd8,0x25,0x24,0x81,0xdf,0xe4,0x56,0x55,0xeb,0x7c,0x44};
	U8 c[64],p[64];
	U8 IV[16];
	int R,c_len[1],p_len[1];
	int i;
	
	for(i=0;i<16;i++)
	{
		IV[i]=0;;
	}
	R=SMS4_CBC_Encrypt(IV,p1,16,key1,16,c,c_len);
	if(R!=0)
	{
		return R;
	}

	for(i=0; i<16; i++)
	{
		if(c[i]!=c1[i]) return 10;
	}

	for(i=0;i<16;i++)
	{
		IV[i]=0;;
	}
	R=SMS4_CBC_Decrypt(IV,c1,16,key1,16,p,p_len);
	if(R!=0)
	{
		return R;
	}

	for(i=0; i<16; i++)
	{
		if(p[i]!=p1[i]) return 11;
	}


	
	

	for(i=0;i<16;i++)
	{
		IV[i]=IV1[i];
	}
	R=SMS4_CBC_Encrypt(IV,p2,64,key2,16,c,c_len);
	if(R!=0)
	{
		return R;
	}

	for(i=0;i<16;i++)
	{
		IV[i]=IV1[i];
	}
	R=SMS4_CBC_Decrypt(IV,c,64,key2,16,p,p_len);
	if(R!=0)
	{
		return R;
	}
	for(i=0; i<64; i++)
	{
		if(p[i]!=p2[i]) return 14;
	}


	

	
	return 0;


}


/*
void main()
{
	int R;


	R=test_SMS4();
	printf("%d\n",R);



}
*/
